clear all; 
set(0,'defaultAxesFontSize',20)

%% intial set-up 
subject = 'combined';
nIterations = 50;
windowLength = 0.4;
windowShiftSize = 0.05;
errorType = 1; % 1 = SEM across iter, 2 = mean SEM across iters, 3 = std across all iters 

workdir = ['/Users/geena/Dropbox/PhD/SUAinfo/Pseudopopulations/balanced/N_50cells/SVM_' subject '/'];

colorArray = [0.4940 0.1840 0.5560;0.6350 0.0780 0.1840;0.8500 0.3250 0.0980;0.9290 0.6940 0.1250];


for iter = 1:nIterations 
    results(iter) = load([workdir '/' subject '_N' num2str(iter) '_SVMresults_' num2str(windowLength) '_' num2str(windowShiftSize) '.mat']);
    perm(iter) = load([workdir '/' subject '_N' num2str(iter) '_permSVMresults_' num2str(windowLength) '_' num2str(windowShiftSize) '.mat']);
end

%% define time axis 
firstWindowCenter = results(1).desiredStart + results(1).windowLength/2;
lastWindowCenter = results(1).desiredEnd - results(1).windowLength/2;
windowsCenter = firstWindowCenter:results(1).windowShiftSize:lastWindowCenter;

arrayList = fieldnames(results(1).validationScoreStruct);
validationScores = [results(:).validationScoreStruct];
SEMScores = [results(:).SEM];
permScores = [perm(:).permValidationScoreStruct];

%% get averages across N pseudopopulations
for aa = 1:length(arrayList)

    allIterResults = [];
    allIterSEMs = [];

    for iter = 1:nIterations

        thisIterResults = validationScores(iter).(arrayList{aa});
        allIterResults = [thisIterResults; allIterResults];

        thisIterSEM = SEMScores(iter).(arrayList{aa});
        allIterSEMs = [thisIterSEM; allIterSEMs];
        
    end

    meanIterValidationScores(aa,:) = mean(allIterResults,1);
    semErrBars(aa,:) = ((std(allIterResults,1) ./ sqrt(nIterations))) ;
    semErrBars_2(aa,:) = (mean(allIterSEMs,1));
    stdErrBars(aa,:) = (std(allIterResults,[],1));

end

if errorType == 1
    errorBars = semErrBars;
elseif errorType == 2
    errorBars = semErrBars_2;
elseif errorType == 3
    errorBars = stdErrBars;

end

%% permutations 98th% as cutoff for significance of decoder
prcThres = 98;
P = zeros(length(arrayList),length(windowsCenter),nIterations);

for aa = 1:length(arrayList)

    for iter = 1:nIterations

        for tt = 1:length(windowsCenter)

            P(aa,tt,iter) = prctile(permScores(iter).(arrayList{aa})(tt,:),prcThres);

        end

    end

end

% Collect iteration matrices per region (real) and per-iteration null means
nTime = numel(windowsCenter);
nReg  = numel(arrayList);

realAcc = cell(nReg,1);        % {aa}: nIter x nTime (real)
nullMean = cell(nReg,1);       % {aa}: nIter x nTime (mean over 100 perms for that iter)


%% -------- Build real matrices and per-iteration null means --------

for r = 1:nReg
    A = zeros(nIterations, nTime);
    B = zeros(nIterations, nTime);
    for iter = 1:nIterations
        % Real: 1 x nTime row
        A(iter,:) = validationScores(iter).(arrayList{r})(:).';
        % Null: nTime x nPerms -> mean over perms (per-iteration null expectation)
        P = permScores(iter).(arrayList{r});   % nTime x nPerms
        B(iter,:) = mean(P, 2, 'omitnan').';
    end
    realAcc{r}  = A;
    nullMean{r} = B;
end

%% -------- Cluster-based permutation parameters --------
alpha_cf = 0.05;     % cluster-forming p-threshold (per-time)
nPerm    = 5000;     % number of permutations for max cluster mass null
useDirectionalBetweenShading = false;  % true: shade by winner color; false: blended color

%% -------- Within-region tests (one-sample; right-tailed real > null mean) --------
within = cell(nReg,1);
for r = 1:nReg
    D = realAcc{r} - nullMean{r};  % nIter x nTime, paired difference per iteration
    within{r} = cluster_perm_onesample(D, 'tail','right', 'alpha_cf',alpha_cf, 'nPerm',nPerm);
    within{r}.label = arrayList{r};
end

%% -------- Between-region tests (two-group; two-sided) --------
pairs = nchoosek(1:nReg, 2);
between = cell(size(pairs,1),1);
for p = 1:size(pairs,1)
    i = pairs(p,1); j = pairs(p,2);
    between{p} = cluster_perm_2group(realAcc{i}, realAcc{j}, 'tail','both', 'alpha_cf',alpha_cf, 'nPerm',nPerm);
    between{p}.labelA = arrayList{i};
    between{p}.labelB = arrayList{j};
end

%% -------- Colormap (exact order must match arrayList) --------
colorArray = [ ...
    0.4940 0.1840 0.5560;  % region 1
    0.6350 0.0780 0.1840;  % region 2
    0.8500 0.3250 0.0980;  % region 3
    0.9290 0.6940 0.1250]; % region 4
% If you have >4 regions, extend colorArray accordingly.

%% -------- Plot: regions vs null (one figure, subplots) --------
plot_regions_vs_null_grid(windowsCenter, realAcc, nullMean, within, arrayList, colorArray);

%% -------- Plot: between-region contrasts (one figure, subplots) --------
plot_between_regions_grid(windowsCenter, realAcc, between, pairs, arrayList, colorArray, useDirectionalBetweenShading);

%% ----------- Diagnostics (optional) -----------
% Quick textual summary of between-region clusters (uncomment to print)

for p = 1:numel(between)
    i = pairs(p,1); j = pairs(p,2);
    S = between{p};
    fprintf('\n=== %s vs %s ===\n', arrayList{i}, arrayList{j});
    fprintf('Any cluster-corrected bins? %s\n', string(any(S.sig_mask)));
    if ~isempty(S.clusters)
        for c = 1:numel(S.clusters)
            seg = S.clusters(c).start:S.clusters(c).end;
            fprintf('  Cluster %d: %d bins, [%g..%g], mass=%.3f, p=%.4g\n', ...
                c, numel(seg), windowsCenter(seg(1)), windowsCenter(seg(end)), S.clusters(c).mass, S.clusters(c).p);
        end
    else
        fprintf('  (No significant clusters)\n');
    end
end


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                               HELPERS                                   %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

function out = cluster_perm_onesample(D, varargin)
% One-sample cluster permutation across time using sign-flips (paired test).
% D: nIter x T deviations (e.g., real - per-iteration null mean).
% Options: 'tail' ('right','left','both'), 'alpha_cf', 'nPerm'
p = inputParser;
addParameter(p,'tail','right',@(s)ischar(s)||isstring(s));
addParameter(p,'alpha_cf',0.05,@(x)isnumeric(x)&&isscalar(x)&&x>0&&x<1);
addParameter(p,'nPerm',5000,@(x)isnumeric(x)&&isscalar(x)&&x>=100);
parse(p,varargin{:});
tail     = lower(string(p.Results.tail));
alpha_cf = p.Results.alpha_cf;
nPerm    = p.Results.nPerm;

% Drop all-NaN columns
keepCols = any(isfinite(D),1);
D = D(:,keepCols);
[nI,T] = size(D);

% Observed t across iterations
[m, s, n] = msd(D);
tObs = m ./ (s ./ sqrt(n));
df   = max(n - 1, 1);

switch tail
    case "both"
        tcrit = tinv(1 - alpha_cf/2, max(df)); mask = abs(tObs) > tcrit; massfun = @(t) sum(abs(t));
    case "right"
        tcrit = tinv(1 - alpha_cf,   max(df)); mask = tObs > tcrit;       massfun = @(t) sum(t);
    case "left"
        tcrit = tinv(1 - alpha_cf,   max(df)); mask = -tObs > tcrit;      massfun = @(t) sum(-t);
    otherwise, error('tail must be right/left/both');
end

obsClusters = label_clusters(mask);
for c = 1:numel(obsClusters)
    seg = obsClusters(c).start:obsClusters(c).end;
    obsClusters(c).mass = massfun(tObs(seg));
end

% Null via sign flips of whole trajectories
maxMass0 = zeros(nPerm,1);
for pidx = 1:nPerm
    sgn = (rand(nI,1) > 0.5)*2 - 1;    % Â±1
    Dp  = D .* sgn;
    [m0,s0,n0] = msd(Dp);
    t0 = m0 ./ (s0 ./ sqrt(n0));
    switch tail
        case "both",  mask0 = abs(t0) > tcrit; mass0 = max_cluster_mass(t0, mask0, @(t) sum(abs(t)));
        case "right", mask0 = t0 > tcrit;      mass0 = max_cluster_mass(t0, mask0, @(t) sum(t));
        case "left",  mask0 = -t0 > tcrit;     mass0 = max_cluster_mass(-t0, mask0, @(t) sum(t));
    end
    maxMass0(pidx) = mass0;
end

sig_mask = false(1,T);
for c = 1:numel(obsClusters)
    cmass = obsClusters(c).mass;
    pcl = (sum(maxMass0 >= cmass) + 1) / (nPerm + 1);  % +1 correction
    obsClusters(c).p = pcl;
    if pcl < 0.05
        sig_mask(obsClusters(c).start:obsClusters(c).end) = true;
    end
end

% Pack (expand back to original T if some columns were dropped)
out.t        = nan(1, size(keepCols,2)); out.t(keepCols) = tObs;
out.sig_mask = false(1, size(keepCols,2)); out.sig_mask(keepCols) = sig_mask;
out.clusters = obsClusters;
out.maxMass0 = maxMass0;
out.info     = struct('tail',tail,'alpha_cf',alpha_cf,'nPerm',nPerm,'nIter',nI,'T',T);
end

function out = cluster_perm_2group(A, B, varargin)
% Two-group cluster permutation across time (independent samples).
% A: nA x T, B: nB x T
p = inputParser;
addParameter(p,'tail','both',@(s)ischar(s)||isstring(s));
addParameter(p,'alpha_cf',0.05,@(x)isnumeric(x)&&isscalar(x)&&x>0&&x<1);
addParameter(p,'nPerm',5000,@(x)isnumeric(x)&&isscalar(x)&&x>=100);
parse(p,varargin{:});
tail     = lower(string(p.Results.tail));
alpha_cf = p.Results.alpha_cf;
nPerm    = p.Results.nPerm;

A = A(:,all(isfinite(mean(A,1))));  % keep finite cols
B = B(:,all(isfinite(mean(B,1))));
[nA,T] = size(A); nB = size(B,1);

[tObs, p_unc] = welch_t(A,B);

% Cluster-forming tcrit (fixed df approximation)
df0   = min(nA-1 + nB-1, max(2, nA+nB-2));
switch tail
    case "both",  tcrit = tinv(1 - alpha_cf/2, df0); supra = abs(tObs) > tcrit; massfun = @(t) sum(abs(t));
    case "right", tcrit = tinv(1 - alpha_cf,   df0); supra = tObs > tcrit;       massfun = @(t) sum(t);
    case "left",  tcrit = tinv(1 - alpha_cf,   df0); supra = -tObs > tcrit;      massfun = @(t) sum(-t);
    otherwise, error('tail must be both/right/left');
end

obsClusters = label_clusters(supra);
for c = 1:numel(obsClusters)
    seg = obsClusters(c).start:obsClusters(c).end;
    obsClusters(c).mass = massfun(tObs(seg));
end

% Permute whole iteration trajectories
X = [A; B];
nTot = size(X,1);
maxMass0 = zeros(nPerm,1);
for pidx = 1:nPerm
    idx = randperm(nTot);
    Ai = X(idx(1:nA),:);
    Bi = X(idx(nA+1:end),:);
    t0 = welch_t(Ai,Bi);
    switch tail
        case "both",  supra0 = abs(t0) > tcrit; mass0 = max_cluster_mass(t0, supra0, @(t) sum(abs(t)));
        case "right", supra0 = t0 > tcrit;      mass0 = max_cluster_mass(t0, supra0, @(t) sum(t));
        case "left",  supra0 = -t0 > tcrit;     mass0 = max_cluster_mass(-t0, supra0, @(t) sum(t));
    end
    maxMass0(pidx) = mass0;
end

sig_mask = false(1,T);
for c = 1:numel(obsClusters)
    cmass = obsClusters(c).mass;
    pcl = (sum(maxMass0 >= cmass) + 1) / (nPerm + 1);
    obsClusters(c).p = pcl;
    if pcl < 0.05
        sig_mask(obsClusters(c).start:obsClusters(c).end) = true;
    end
end

out.t        = tObs;
out.p_unc    = p_unc;
out.sig_mask = sig_mask;
out.clusters = obsClusters;
out.maxMass0 = maxMass0;
out.info     = struct('tail',tail,'alpha_cf',alpha_cf,'nPerm',nPerm,'nA',nA,'nB',nB,'T',T);
end

function [t, p] = welch_t(A,B)
% Vectorized Welch t-test across time (independent samples)
mA = mean(A,1,'omitnan'); vA = var(A,0,1,'omitnan'); nA = sum(isfinite(A),1);
mB = mean(B,1,'omitnan'); vB = var(B,0,1,'omitnan'); nB = sum(isfinite(B),1);
se = sqrt(vA./nA + vB./nB);
t  = (mA - mB) ./ se;
df = (vA./nA + vB./nB).^2 ./ ( (vA./nA).^2./max(nA-1,1) + (vB./nB).^2./max(nB-1,1) );
p  = 2 * (1 - tcdf(abs(t), df));
end

function clusters = label_clusters(mask)
% mask: 1xT logical -> struct array with .start, .end
idx = find(mask(:)');
clusters = struct('start',{},'end',{},'mass',{});
if isempty(idx), return; end
splits = [1, find(diff(idx) > 1) + 1, numel(idx)+1];
for s = 1:numel(splits)-1
    seg = idx(splits(s):splits(s+1)-1);
    clusters(end+1).start = seg(1); %#ok<AGROW>
    clusters(end).end     = seg(end);
end
end

function m = max_cluster_mass(t, mask, massfun)
cls = label_clusters(mask);
if isempty(cls), m = 0; return; end
ms = zeros(numel(cls),1);
for c = 1:numel(cls)
    seg = cls(c).start:cls(c).end;
    ms(c) = massfun(t(seg));
end
m = max(ms);
end

function [m,s,n] = msd(X)
m = mean(X,1,'omitnan');
s = std(X,0,1,'omitnan');
n = sum(isfinite(X),1);
s(s==0) = inf;  % so t=0 where variance is 0
end

%% -------------------- Plotting helpers --------------------

function plot_regions_vs_null_grid(tCenters, realAcc, nullMean, within, arrayList, colorArray)
nReg = numel(arrayList);
[rows, cols] = bestSubplotGrid(nReg);
fig = figure('Color','w','Name','Regions vs Null (cluster-corrected)');

for r = 1:nReg
    ax = subplot(rows, cols, r, 'Parent', fig); hold(ax,'on');
    c  = colorArray(min(r,size(colorArray,1)),:);
    cDark  = darkenColor(c, 0.45);   % shading
    cLight = lightenColor(c, 0.55);  % null line

    mR = mean(realAcc{r},1,'omitnan'); sR = std(realAcc{r},0,1,'omitnan') ./ sqrt(size(realAcc{r},1));
    mN = mean(nullMean{r},1,'omitnan'); sN = std(nullMean{r},0,1,'omitnan') ./ sqrt(size(nullMean{r},1));

    hR = errorbar(ax, tCenters, mR, sR, '-', 'LineWidth',1.8, 'Color', c,      'CapSize',0);
    hN = errorbar(ax, tCenters, mN, sN, '-', 'LineWidth',1.2, 'Color', cLight, 'CapSize',0, 'LineStyle','--');

    % Shade significant bins (after lines; uses bin edges, handles 1-bin clusters)
    shade_sig_ax(ax, tCenters, within{r}.sig_mask, cDark, 0.30);

    if r==1
        legend(ax, [hR hN], {'real','null mean'}, 'Location','best');
    end
    xlabel(ax,'Time'); ylabel(ax,'Decoding accuracy');
    title(ax, sprintf('%s: real > null (cluster-corr)', arrayList{r}));
    grid(ax,'on'); box(ax,'off');
end
end

function plot_between_regions_grid(tCenters, realAcc, between, pairs, arrayList, colorArray, useDirectional)
nPairs = size(pairs,1);
[rows, cols] = bestSubplotGrid(nPairs);
fig = figure('Color','w','Name','Between-Region Contrasts (cluster-corrected)');

for p = 1:nPairs
    i = pairs(p,1); j = pairs(p,2);
    ax = subplot(rows, cols, p, 'Parent', fig); hold(ax,'on');

    cA = colorArray(min(i,size(colorArray,1)),:);
    cB = colorArray(min(j,size(colorArray,1)),:);

    mA = mean(realAcc{i},1,'omitnan'); sA = std(realAcc{i},0,1,'omitnan') ./ sqrt(size(realAcc{i},1));
    mB = mean(realAcc{j},1,'omitnan'); sB = std(realAcc{j},0,1,'omitnan') ./ sqrt(size(realAcc{j},1));

    hA = errorbar(ax, tCenters, mA, sA, '-', 'LineWidth',1.8, 'Color', cA, 'CapSize',0);
    hB = errorbar(ax, tCenters, mB, sB, '-', 'LineWidth',1.8, 'Color', cB, 'CapSize',0, 'LineStyle','--');

    if useDirectional
        shade_sig_signed_ax(ax, tCenters, between{p}.sig_mask, between{p}.t, cA, cB, 0.30);
    else
        cBlend = darkenColor( (cA + cB)/2, 0.45 );
        shade_sig_ax(ax, tCenters, between{p}.sig_mask, cBlend, 0.30);
    end

    if p==1
        legend(ax, [hA hB], {arrayList{i}, arrayList{j}}, 'Location','best');
    end
    xlabel(ax,'Time'); ylabel(ax,'Decoding accuracy');
    title(ax, sprintf('%s vs %s (cluster-corr)', arrayList{i}, arrayList{j}));
    grid(ax,'on'); box(ax,'off');
end
end

function shade_sig_ax(ax, tCenters, mask, colorRGB, alphaVal)
% Shade significant clusters using bin edges (robust to 1-bin clusters)
if isempty(mask) || ~any(mask), return; end
edges = bin_edges_from_centers(tCenters);
segs  = logical_mask_to_segments(mask);
yl = ylim(ax);
for s = 1:size(segs,1)
    i0 = segs(s,1);
    i1 = segs(s,2);
    x0 = edges(i0);
    x1 = edges(i1+1);
    patch('Parent',ax, ...
          'XData',[x0 x1 x1 x0], 'YData',[yl(1) yl(1) yl(2) yl(2)], ...
          'FaceColor', colorRGB, 'FaceAlpha', alphaVal, 'EdgeColor','none');
end
uistack(findobj(ax,'Type','patch'),'bottom');
end

function shade_sig_signed_ax(ax, tCenters, mask, tvals, colorPos, colorNeg, alphaVal)
% Directional shading: colorPos when mean t>0 (A>B), colorNeg when mean t<0 (B>A)
if isempty(mask) || ~any(mask), return; end
edges = bin_edges_from_centers(tCenters);
segs  = logical_mask_to_segments(mask);
yl = ylim(ax);
for s = 1:size(segs,1)
    idx = segs(s,1):segs(s,2);
    useCol = colorPos;
    if mean(tvals(idx),'omitnan') < 0, useCol = colorNeg; end
    x0 = edges(idx(1)); x1 = edges(idx(end)+1);
    patch('Parent',ax, ...
          'XData',[x0 x1 x1 x0], 'YData',[yl(1) yl(1) yl(2) yl(2)], ...
          'FaceColor', useCol, 'FaceAlpha', alphaVal, 'EdgeColor','none');
end
uistack(findobj(ax,'Type','patch'),'bottom');
end

function edges = bin_edges_from_centers(c)
% Convert center times to edges (works for non-uniform spacing)
c = c(:)'; 
if numel(c) == 1
    d = 1; edges = [c(1)-d/2, c(1)+d/2]; return;
end
mid   = (c(1:end-1) + c(2:end))/2;
left  = c(1)  - (mid(1) - c(1));
right = c(end) + (c(end) - mid(end));
edges = [left, mid, right];
end

function segs = logical_mask_to_segments(mask)
% Return Nx2 [startIdx endIdx] for contiguous true segments (1-based)
mask = mask(:)'; idx = find(mask);
segs = zeros(0,2);
if isempty(idx), return; end
brks = [1, find(diff(idx) > 1)+1, numel(idx)+1];
for b = 1:numel(brks)-1
    seg = idx(brks(b):brks(b+1)-1);
    segs(end+1,:) = [seg(1) seg(end)]; %#ok<AGROW>
end
end

function [rows, cols] = bestSubplotGrid(N)
rows = floor(sqrt(N));
cols = ceil(N / max(rows,1));
if rows*cols < N, rows = rows + 1; end
end

function c2 = darkenColor(c, amt)  % blend toward black
c2 = max(0, (1-amt).*c);
end

function c2 = lightenColor(c, amt) % blend toward white
c2 = min(1, c + (1-c).*amt);
end

