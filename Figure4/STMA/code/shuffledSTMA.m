function [tmpSTMA,simSpikeTimesAdj] = shuffledSTMA(ii, diffFrames, pixelRows, pixelColumns, spikes, cameraSync, bhvSR, windowSize, directionality,shuffleWindow)


% INPUTS:
% ii = iteration occurring; not used in this function, but important for
%           parforloop in general; this is the single looping variable
%           you're allowed 
% diffIntensity = broadcast variable (hence making it data format 'single', to be
%               smaller); nPixel x mPixel x nFrames array of absolute
%               differential luminance values
% spikes = vector of spike times taken from obhv.spikes.el
% duration = duration in seconds of recording 
% FT2time = vector of timestamps from Motive (one per frame)
% incompleteAVIflag = 0/1, if all frames exported from Motive (impt to not
%                     include spiketimes occurring outside of exported
%                     frames)
% frameStart/end = if incompleteAVI, indicate 
% windowSize = in sec, to compute STA (ie, 2 sec = 242 frames)
% ch/unit = neuron to examine
% directionality = 'pre'/'post'; 'post' will compute STA of windowSize
%                               AFTER spiketimes; 'pre' for sensory neuron
% shuffleMethod = 'smallWindow' (default) will shuffle spike times within
%                   specified windowSize -- if none given, will default to
%                   shuffling spiketimes across entire recording (bad,
%                   probably want to fix this) 
% shuffleWindow =  window in seconds, to shuffle spiketimes
% plotFlag = 0/1;  plot shuffled spiketimes 

% OUTPUTS: tmpSTMA = single iteration of "null distribution" STMA, generated by shuffled spike times;
%            dimensions are pixelWidth x pixelHeight x nFrames 
%            fourth dimension, (nIterations) gets filled over parforloop

% DEPENDENCIES: generate_randomSpikeTrain.m
%               getFrameBounds4STMA_sim.m
%               evTrigAvg2_sim_linearized.m

%%%%%%%%%%%%%%%%%%%

postSpikeFrames = ceil(bhvSR*windowSize);

%preallocate
tmpSTMA = zeros(pixelRows,pixelColumns,postSpikeFrames+1);   

%generate a shuffled, simulated spike train based on FR of neuron of
%interest
[randSpikeTrain] = generateShuffledSpikeTrain(spikes, shuffleWindow);

%based on shuffled spiketimes, return frame#s 
%for which to average diffIntensity
[simSpikeTimesAdj, framesLowerBound, framesUpperBound] = frameBounds4STMA2021(randSpikeTrain, cameraSync, bhvSR, directionality, windowSize);


%important note!
% linearly index your pixels (or any variable that has 2 components you
% want to loop over) -- this speeds up the code significantly!!

for i = 1:pixelColumns*pixelRows    
        
        [pixelRow, pixelColumn] = ind2sub([pixelRows pixelColumns], i); %convert linear index back into subscripts
        currPixel = squeeze(diffFrames(pixelRow,pixelColumn,:))'; 
        
        % for each spike, use frameBounds to index into currPixel, compute
        % average over all spike times, & return average
        [avg_r, ~, nSpikes] = getSpTrigAvg2021(currPixel, simSpikeTimesAdj, framesLowerBound, framesUpperBound, directionality, windowSize, postSpikeFrames);
        
        %IMPORTANT: note how we use the subscripts we created
        %(pixelRow/column) to put avg_r back in the correct place;
        % you cannot do this directly bc parforloops only allow a single
        % indexing variable, so create two INSIDE the loop each time
        tmpSTMA(pixelRow, pixelColumn, :) = avg_r;

end

end
